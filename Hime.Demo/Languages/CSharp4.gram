public grammar cf CSharp4
{
	options
	{
		Axiom = "compilation_unit";
		Separator = "SEPARATOR";
	}
	terminals
	{
		NEW_LINE		-> 0x000D /* CR */
						|  0x000A /* LF */
						|  0x000D 0x000A /* CR LF */
						|  0x2028 /* LS */
						|  0x2029 /* PS */ ;
		WHITE_SPACE		-> 0x0020 | 0x0009 | 0x000B | 0x000C ;
		COMMENT_LINE	-> '//' (.* - (.* NEW_LINE .*)) NEW_LINE ;
		COMMENT_BLOCK	-> '/*' (.* - (.* '*/' .*)) '*/' ;
		SEPARATOR		-> (NEW_LINE | WHITE_SPACE | COMMENT_LINE | COMMENT_BLOCK)+;
		
		IDENTIFIER		-> '@'? [a-zA-Z] [a-zA-Z0-9_]* ;

		NULL_LITTERAL				-> 'null' ;
		BOOLEAN_LITTERAL_TRUE		-> 'true' ;
		BOOLEAN_LITTERAL_FALSE		-> 'false' ;
		INTEGER_LITTERAL_SUFFIX		-> 'U' | 'u' | 'L' | 'l' | 'UL' | 'Ul' | 'uL' | 'ul' | 'LU' | 'Lu' | 'lU' | 'lu' ;
		INTEGER_LITTERAL_DECIMAL	-> [1-9] [0-9]* | '0' INTEGER_LITTERAL_SUFFIX? ;
		INTEGER_LITTERAL_HEXA		-> '0' ('x' | 'X') [a-fA-F0-9]+ INTEGER_LITTERAL_SUFFIX? ;
		REAL_LITTERAL_SUFFIX		-> 'F' | 'f' | 'D' | 'd' | 'M' | 'm' ;
		REAL_LITTERAL				-> INTEGER_LITTERAL_DECIMAL? '.' INTEGER_LITTERAL_DECIMAL  (('e' | 'E') ('+' | '-')? INTEGER_LITTERAL_DECIMAL)? REAL_LITTERAL_SUFFIX?
									|  INTEGER_LITTERAL_DECIMAL ('e' | 'E') ('+' | '-')? INTEGER_LITTERAL_DECIMAL REAL_LITTERAL_SUFFIX?
									|  INTEGER_LITTERAL_DECIMAL REAL_LITTERAL_SUFFIX ;
		CHARACTER_LITTERAL			-> '\'' ( (0x0000 .. 0xFFFF - ('\'' | '\\' | NEW_LINE))
											| '\\' ('\'' | '"' | '\'' | '\\' | [0abfnrtv])
											| '\\' 'x' [a-fA-F0-9] [a-fA-F0-9]? [a-fA-F0-9]? [a-fA-F0-9]?
											| '\\' ('u' | 'U') [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] ([a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9])?
										) '\'' ;
		STRING_LITTERAL_REGULAR		-> '"'  ( (0x0000 .. 0xFFFF - ('"' | '\\' | NEW_LINE))
											| '\\' ('\'' | '"' | '\'' | '\\' | [0abfnrtv])
											| '\\' 'x' [a-fA-F0-9] [a-fA-F0-9]? [a-fA-F0-9]? [a-fA-F0-9]?
											| '\\' ('u' | 'U') [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] ([a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9] [a-fA-F0-9])?
										)* '"' ;
		STRING_LITTERAL_VERBATIM	-> '@' '"' ([^"] | '""')* '"' ;
	}
	rules
	{
		/* B.2.1 Basic Concepts */
		name_nmspce_type		-> IDENTIFIER type_argument_list?
								|  name_nmspce_type '.' IDENTIFIER type_argument_list?
								|  name_qualified_alias ;
		type_argument_list		-> '<' type_arguments '>' ;
		type_arguments			-> type (',' type)* ;
		name_qualified_alias	-> IDENTIFIER '::' IDENTIFIER type_argument_list? ;
		name_simple				-> IDENTIFIER type_argument_list? ;
		
		
		/* B.2.2 Types */
		type					-> name_nmspce_type
								|  type_reference
								|  type_value
								|  type_parameter ;
		type_parameter			-> IDENTIFIER ;
		type_value				-> type_struct ;
		type_struct				-> type_simple
								|  type_nullable ;
		type_simple				-> type_numeric
								|  'bool' ;
		type_numeric			-> type_int
								|  type_float
								|  'decimal' ;
		type_int				-> 'sbyte'
								|  'byte'
								|  'short'
								|  'ushort'
								|  'int'
								|  'uint'
								|  'long'
								|  'ulong'
								|  'char' ;
		type_float				-> 'float'
								|  'double' ;
		type_nullable			-> type '?' ;
		type_reference			-> type_class
								|  type_array ;
		type_class				-> 'object'
								|  'dynamic'
								|  'string' ;
		type_array				-> type type_rank_specifiers ;
		type_rank_specifiers	-> type_rank_specifier+ ;
		type_rank_specifier		-> '[' type_dim_separator* ']' ;
		type_dim_separator		-> ',' ;
		type_return				-> 'void' | type ;
		type_predefined			-> type_simple | 'object' ;
		type_unbound			-> IDENTIFIER generic_dim_specifier?
								|  IDENTIFIER '::' IDENTIFIER generic_dim_specifier?
								|  type_unbound '.' IDENTIFIER generic_dim_specifier? ;
		generic_dim_specifier	-> '<' ','* '>' ;
		
		
		/* B.2.4 Expressions */
		exp_arg_list			-> exp_arg (',' exp_arg)* ;
		exp_arg					-> (IDENTIFIER ':')? exp_arg_value ;
		exp_arg_value			-> ('ref' | 'out')? expression ;
		
		exp_primary				-> exp_primary_no_array
								|  exp_array_creation ;
		exp_primary_no_array	-> exp_literal
								|  exp_simple_name
								|  exp_parenthesized
								|  exp_member_acccess
								|  exp_invocation
								|  exp_element_access
								|  exp_this_access
								|  exp_base_access
								|  exp_post_inc
								|  exp_post_dec
								|  exp_obj_creation
								|  exp_delegate_creation
								|  exp_obj_creation_anon
								|  exp_typeof
								|  exp_checked
								|  exp_unchecked
								|  exp_default_value
								|  exp_anon_method ;
		exp_literal				-> NULL_LITTERAL
								|  BOOLEAN_LITTERAL_TRUE
								|  BOOLEAN_LITTERAL_FALSE
								|  INTEGER_LITTERAL_DECIMAL
								|  INTEGER_LITTERAL_HEXA
								|  REAL_LITTERAL
								|  CHARACTER_LITTERAL
								|  STRING_LITTERAL_REGULAR
								|  STRING_LITTERAL_VERBATIM ;
		exp_simple_name			-> IDENTIFIER type_argument_list? ;
		exp_parenthesized		-> '(' expression ')' ;
		exp_member_acccess		-> exp_primary '.' IDENTIFIER type_argument_list?
								|  type_predefined '.' IDENTIFIER type_argument_list?
								|  name_qualified_alias '.' IDENTIFIER ;
		exp_invocation			-> exp_primary '(' exp_arg_list? ')' ;
		exp_element_access		-> exp_primary_no_array '[' exp_arg_list ']' ;
		exp_this_access			-> 'this' ;
		exp_base_access			-> 'base' '.' IDENTIFIER
								|  'base' '[' exp_arg_list ']' ;
		exp_post_inc			-> exp_primary '++' ;
		exp_post_dec			-> exp_primary '--' ;
		exp_obj_creation		-> 'new' type '(' exp_arg_list? ')' exp_obj_collec_init?
								|  'new' type exp_obj_collec_init ;
		exp_obj_collec_init		-> exp_object_init | exp_collec_init ;
		exp_object_init			-> '{' exp_mem_init_list? '}'
								|  '{' exp_mem_init_list ',' '}' ;
		exp_mem_init_list		-> exp_mem_init (',' exp_mem_init)* ;
		exp_mem_init			-> IDENTIFIER '=' exp_init_value ;
		exp_init_value			-> expression | exp_obj_collec_init ;
		exp_collec_init			-> '{' exp_elem_init_list ','? '}' ;
		exp_elem_init_list		-> exp_elem_init (',' exp_elem_init)* ;
		exp_elem_init			-> exp_non_assignment
								|  '{' exp_list '}' ;
		exp_list				-> expression (',' expression)* ;
		exp_delegate_creation	-> 'new' name_nmspce_type '(' expression ')' ;
		exp_obj_creation_anon	-> 'new' exp_anon_obj_init ;
		exp_anon_obj_init		-> '{' exp_mem_decl_list? '}'
								|  '{' exp_mem_decl_list ',' '}' ;
		exp_mem_decl_list		-> exp_mem_decl (',' exp_mem_decl)* ;
		exp_mem_decl			-> exp_member_acccess
								|  name_simple
								|  IDENTIFIER '=' expression ;
		exp_array_creation		-> 'new' type '[' exp_list ']' type_rank_specifiers? array_init?
								|  'new' type_array array_init
								|  'new' type_rank_specifier array_init ;
		exp_typeof				-> 'typeof' '(' type ')'
								|  'typeof' '(' 'void' ')'
								|  'typeof' '(' type_unbound ')' ;
		exp_checked				-> 'checked' '(' expression ')' ;
		exp_unchecked			-> 'unchecked' '(' expression ')' ;
		exp_default_value		-> 'default' '(' expression ')' ;
		exp_anon_method			-> 'delegate' func_anon_sign_explicit? stmt_block ;
		
		exp_unary				-> exp_primary
								|  '+' exp_primary
								|  '-' exp_primary
								|  '!' exp_primary
								|  '~' exp_primary
								|  exp_pre_inc
								|  exp_pre_dec
								|  exp_cast ;
		exp_pre_inc				-> '++' exp_unary ;
		exp_pre_dec				-> '--' exp_unary ;
		exp_cast				-> '(' type ')' exp_unary ;
		exp_multiplicative		-> exp_unary
								|  exp_multiplicative '*' exp_unary
								|  exp_multiplicative '/' exp_unary
								|  exp_multiplicative '%' exp_unary ;
		exp_additive			-> exp_multiplicative
								|  exp_additive '+' exp_multiplicative
								|  exp_additive '-' exp_multiplicative ;
		exp_shift				-> exp_additive
								|  exp_shift '<<' exp_additive
								|  exp_shift '>|>' exp_additive ;
		exp_relational			-> exp_shift
								|  exp_relational '<' exp_shift
								|  exp_relational '>' exp_shift
								|  exp_relational '<=' exp_shift
								|  exp_relational '<=' exp_shift
								|  exp_relational 'is' type
								|  exp_relational 'as' type ;
		exp_equality			-> exp_relational
								|  exp_equality '==' exp_relational
								|  exp_equality '!=' exp_relational ;
		exp_and					-> exp_equality
								|  exp_and '&' exp_equality ;
		exp_xor					-> exp_and
								|  exp_xor '^' exp_and ;
		exp_incl_or				-> exp_xor
								|  exp_incl_or '|' exp_xor ;
		exp_cond_and			-> exp_incl_or
								|  exp_cond_and '&&' exp_incl_or ;
		exp_cond_or				-> exp_cond_and
								|  exp_cond_or '||' exp_cond_and ;
		exp_null_coelescing		-> exp_cond_or
								|  exp_cond_or '??' exp_null_coelescing ;
		exp_conditional			-> exp_null_coelescing
								|  exp_null_coelescing '?' expression ':' expression ;
		exp_lambda				-> func_anon_sign '=>' func_anon_body ;
		func_anon_sign			-> func_anon_sign_explicit
								|  func_anon_sign_implicit ;
		func_anon_sign_explicit	-> '(' func_explicit_param_list? ')' ;
		func_anon_sign_implicit	-> '(' func_implicit_param_list? ')'
								|  func_implicit_param ;
		func_explicit_param_list-> func_explicit_param (',' func_explicit_param)* ;
		func_implicit_param_list-> func_implicit_param (',' func_implicit_param)* ;
		func_explicit_param		-> func_explicit_param_modifier? type IDENTIFIER ;
		func_implicit_param		-> IDENTIFIER ;
		func_explicit_param_modifier	-> 'ref' | 'out' ;
		func_anon_body			-> expression
								|  stmt_block ;
		
		exp_query				-> exp_query_from exp_query_body ;
		exp_query_from			-> 'from' type? IDENTIFIER 'in' expression ;
		exp_query_body			-> exp_query_body_clauses?
									exp_query_select_group
									exp_query_continuation? ;
		exp_query_body_clauses	-> exp_query_body_clause+ ;
		exp_query_body_clause	-> exp_query_from
								|  exp_query_let
								|  exp_query_where
								|  exp_query_join
								|  exp_query_joint_into
								|  exp_query_orderby ;
		exp_query_let			-> 'let' IDENTIFIER '=' expression ;
		exp_query_where			-> 'where' expression ;
		exp_query_join			-> 'join' type? IDENTIFIER
									'in' expression
									'on' expression
									'equals' expression ;
		exp_query_joint_into	-> 'join' type? IDENTIFIER
									'in' expression
									'on' expression
									'equals' expression
									'into' IDENTIFIER ;
		exp_query_orderby		-> 'orderby' exp_query_orderings ;
		exp_query_orderings		-> exp_query_ordering+;
		exp_query_ordering		-> expression exp_query_direction? ;
		exp_query_direction		-> 'ascending'
								|  'descending' ;
		exp_query_select_group	-> exp_query_select
								|  exp_query_group ;
		exp_query_select		-> 'select' expression ;
		exp_query_group			-> 'group' expression 'by' expression ;
		exp_query_continuation	-> 'into' IDENTIFIER exp_query_body ;
		
		exp_assignment			-> exp_unary '=' expression
								|  exp_unary '+=' expression
								|  exp_unary '-=' expression
								|  exp_unary '*=' expression
								|  exp_unary '/=' expression
								|  exp_unary '%=' expression
								|  exp_unary '&=' expression
								|  exp_unary '|=' expression
								|  exp_unary '^=' expression
								|  exp_unary '<<=' expression
								|  exp_unary '>|>=' expression ;
		
		expression				-> exp_assignment
								|  exp_non_assignment ;
		exp_non_assignment		-> exp_conditional
								|  exp_lambda
								|  exp_query ;
		
		
		/* B.2.5 Statements */
		statement				-> stmt_labeled
								|  stmt_declaration
								|  stmt_embedded ;
		stmt_labeled			-> IDENTIFIER ':' statement ;
		stmt_declaration		-> stmt_declaration_var ';'
								|  stmt_declaration_const ';' ;
		stmt_declaration_var	-> (type | 'var') var_declarators ;
		var_declarators			-> var_declarator (',' var_declarator)* ;
		var_declarator			-> IDENTIFIER ('=' var_init)? ;
		var_init				-> expression
								|  array_init ;
		var_init_list			-> var_init (',' var_init)* ;
		array_init				-> '{' var_init_list? '}'
								|  '{' var_init_list ',' '}';
		stmt_declaration_const	-> 'const' type const_declarators ;
		const_declarators		-> const_declarator (',' const_declarator)* ;
		const_declarator		-> IDENTIFIER '=' expression ;
		stmt_embedded			-> stmt_block
								|  stmt_empty
								|  stmt_exp
								|  stmt_selection
								|  stmt_iteration
								|  stmt_jump
								|  stmt_try
								|  stmt_checked
								|  stmt_unchecked
								|  stmt_lock
								|  stmt_using
								|  stmt_yield ;
		stmt_block				-> '{' statement* '}' ;
		stmt_empty				-> ';' ;
		stmt_exp				-> (exp_invocation
									| exp_obj_creation
									| exp_assignment
									| exp_post_inc
									| exp_post_dec
									|  exp_pre_inc
									|  exp_pre_dec
									) ';' ;
		stmt_exp_list			-> stmt_exp (',' stmt_exp)* ;
		stmt_selection			-> stmt_if
								|  stmt_switch ;
		stmt_if					-> 'if' '(' expression ')' stmt_embedded ('else' stmt_embedded)? ;
		stmt_switch				-> 'switch' '(' expression ')' stmt_switch_block ;
		stmt_switch_block		-> '{' stmt_switch_sections '}' ;
		stmt_switch_sections	-> stmt_switch_section* ;
		stmt_switch_section		-> stmt_switch_labels statement+ ;
		stmt_switch_labels		-> stmt_switch_label+ ;
		stmt_switch_label		-> 'case' expression ':'
								|  'default' ':' ;
		stmt_iteration			-> stmt_while
								|  stmt_do
								|  stmt_for
								|  stmt_foreach ;
		stmt_while				-> 'while' '(' expression ')' stmt_embedded ;
		stmt_do					-> 'do' stmt_embedded 'while' '(' expression ')' ';' ;
		stmt_for				-> 'for' '('
									stmt_for_init? ';'
									stmt_for_cond? ';'
									stmt_for_iterator?
									')' stmt_embedded ;
		stmt_for_init			-> stmt_declaration_var
								|  stmt_exp_list ;
		stmt_for_cond			-> expression ;
		stmt_for_iterator		-> stmt_exp_list ;
		stmt_foreach			-> 'foreach' '('
									(type | 'var') IDENTIFIER
									'in' expression
									')' stmt_embedded ;
		stmt_jump				-> stmt_break
								|  stmt_continue
								|  stmt_goto
								|  stmt_return
								|  stmt_throw ;
		stmt_break				-> 'break' ';' ;
		stmt_continue			-> 'continue' ';' ;
		stmt_goto				-> 'goto' IDENTIFIER ';'
								|  'goto' 'case' expression ';'
								|  'goto' 'default' ';' ;
		stmt_return				-> 'return' expression? ';' ;
		stmt_throw				-> 'throw' expression? ';' ;
		stmt_try				-> 'try' stmt_block stmt_try_catches
								|  'try' stmt_block stmt_try_finally
								|  'try' stmt_block stmt_try_catches stmt_try_finally ;
		stmt_try_catches		-> stmt_try_catch_specifics
								|  stmt_try_catch_specifics stmt_try_catch_general
								|  stmt_try_catch_general ;
		stmt_try_catch_specifics-> stmt_try_catch_specific+ ;
		stmt_try_catch_specific	-> 'catch' '('
									(type_class | name_nmspce_type)
									IDENTIFIER?
									')' stmt_block ;
		stmt_try_catch_general	-> 'catch' stmt_block ;
		stmt_try_finally		-> 'finally' stmt_block ;
		stmt_checked			-> 'checked' stmt_block ;
		stmt_unchecked			-> 'unchecked' stmt_block ;
		stmt_lock				-> 'lock' '(' expression ')' stmt_embedded ;
		stmt_using				-> 'using' '(' stmt_declaration_var | expression ')' stmt_embedded;
		stmt_yield				-> 'yield' 'return' expression ';'
								|  'yield' 'break' ';' ;
		
		
		/* B.2.6 Namespaces */
		directives_extern_alias			-> directive_extern_alias* ;
		directive_extern_alias			-> 'extern' 'alias' IDENTIFIER ';' ;
		directives_using				-> directive_using* ;
		directive_using					-> directive_using_namespace | directive_using_alias ;
		directive_using_namespace		-> 'using' name_nmspce_type ';' ;
		directive_using_alias			-> 'using' IDENTIFIER '=' name_nmspce_type ';' ;
		
		namespace_member_declaration	-> type_declaration
										|  namespace_declaration ;
		type_declaration				-> class_declaration
										|  inter_declaration
										|  struct_declaration
										|  inter_declaration
										|  enum_declaration
										|  delg_declaration ;
		namespace_members				-> namespace_member_declaration* ;
		namespace_body					-> '{'
												directives_extern_alias
												directives_using
												namespace_members
											'}' ;
		namespace_declaration			-> 'namespace' name_nmspce_type namespace_body ';'? ;
		
		compilation_unit				-> directives_extern_alias
											directives_using
											global_attributes
											namespace_members ;
		
		
		/* B.2.7 Classes */
		class_declaration				-> attributes class_access? class_modifiers 'partial'?
											'class' IDENTIFIER type_parameter_list?
											class_base? type_param_cnstr_clauses?
											class_body ';'? ;
		class_access					-> 'public'
										|  'private'
										|  'protected'
										|  'internal'
										|  'protected' 'internal' ;
		class_modifiers					-> class_modifier* ;
		class_modifier					-> 'new'
										|  'static'
										|  'abstract'
										|  'sealed' ;
		type_parameter_list				-> '<' type_parameters '>' ;
		type_parameters					-> attributes type_parameter (',' attributes type_parameter)* ;
		type_parameter					-> IDENTIFIER ;
		class_base						-> ':' type_class (
												(',' (type_class | name_nmspce_type))*
											)? ;
		type_param_cnstr_clauses		-> type_param_cnstr_clause+ ;
		type_param_cnstr_clause			-> 'where' type_parameter ':' type_param_cnstrs ;
		type_param_cnstrs				-> type_param_cnstr_primary
										|  type_param_cnstr_secondaries
										|  type_param_cnstr_constructor
										|  type_param_cnstr_primary ',' type_param_cnstr_secondaries
										|  type_param_cnstr_primary ',' type_param_cnstr_constructor
										|  type_param_cnstr_secondaries ',' type_param_cnstr_constructor
										|  type_param_cnstr_primary ',' type_param_cnstr_secondaries ',' type_param_cnstr_constructor ;
		type_param_cnstr_primary		-> type_class
										|  name_nmspce_type
										|  'class'
										|  'struct' ;
		type_param_cnstr_secondaries	-> type_param_cnstr_secondary (',' type_param_cnstr_secondary)* ;
		type_param_cnstr_secondary		-> name_nmspce_type
										|  type_parameter ;
		type_param_cnstr_constructor	-> 'new' '(' ')' ;
		class_body						-> '{' class_member* '}' ;
		class_member					-> class_constant
										|  class_field
										|  class_method
										|  class_property
										|  class_event
										|  class_indexer
										|  class_operator
										|  class_constructor
										|  class_destructor
										|  class_static_ctor
										|  type_declaration ;
		class_constant					-> attributes class_access? 'new'?
											'const' type const_declarators ';' ;
		class_field						-> attributes class_access? class_field_modifiers
											type var_declarators ';' ;
		class_field_modifiers			-> class_field_modifier* ;
		class_field_modifier			-> 'new'
										|  'static'
										|  'readonly'
										|  'volatile' ;
		class_method					-> class_method_header class_method_body ;
		class_method_header				-> attributes class_access? class_method_modifiers 'partial'?
											type_return name_nmspce_type type_parameter_list?
											'(' class_method_param_list? ')'
											type_param_cnstr_clauses? ;
		class_method_modifiers			-> class_method_modifier* ;
		class_method_modifier			-> 'new'
										|  'static'
										|  'virtual'
										|  'sealed'
										|  'override'
										|  'abstract'
										|  'extern' ;
		class_method_param_list			-> class_method_params
										|  class_method_params ',' param_array
										|  param_array ;
		class_method_params				-> class_method_param (',' class_method_params)* ;
		class_method_param				-> attributes class_method_param_modifier?
											type IDENTIFIER class_method_param_default? ;
		class_method_param_modifier		-> 'ref'
										|  'out'
										|  'this' ;
		class_method_param_default		-> '=' expression ;
		param_array						-> attributes 'params' type_array IDENTIFIER ;
		class_method_body				-> stmt_block | ';' ;
		class_property					-> attributes class_access? class_method_modifier
											type name_nmspce_type
											'{' class_property_accessors '}' ;
		class_property_accessors		-> class_property_get
										|  class_property_set
										|  class_property_get class_property_set
										|  class_property_set class_property_get ;
		class_property_get				-> attributes class_accessor_modifier? 'get' class_accessor_body ;
		class_property_set				-> attributes class_accessor_modifier? 'set' class_accessor_body ;
		class_accessor_modifier			-> 'protected'
										|  'internal'
										|  'private'
										|  'protected' 'internal'
										|  'internal' 'protected' ;
		class_accessor_body				-> stmt_block | ';' ;
		class_event						-> attributes class_access? class_method_modifier
											'event' type var_declarators ';'
										|  attributes class_access? class_method_modifier
											'event' type name_nmspce_type
											'{' class_event_accessors '}' ;
		class_event_accessors			-> class_event_add
										|  class_event_remove
										|  class_event_add class_event_remove
										|  class_event_remove class_event_add ;
		class_event_add					-> attributes 'add' stmt_block ;
		class_event_remove				-> attributes 'remove' stmt_block ;
		class_indexer					-> attributes class_access? class_method_modifier
											class_indexer_decl
											'{' class_property_accessors '}' ;
		class_indexer_decl				-> type 'this' '[' class_method_param_list ']'
										|  type name_nmspce_type '.' 'this' '[' class_method_param_list ']';
		class_operator					-> attributes class_operator_modifiers
											class_operator_decl class_operator_body ;
		class_operator_modifiers		-> class_operator_modifier* ;
		class_operator_modifier			-> 'public'
										|  'static'
										|  'extern' ;
		class_operator_decl				-> class_operator_decl_unary
										|  class_operator_decl_binary
										|  class_operator_decl_conversion ;
		class_operator_decl_unary		-> type 'operator' overload_op_unary
											'(' type IDENTIFIER ')' ;
		overload_op_unary				-> '+'
										|  '-'
										|  '!'
										|  '~'
										|  '++'
										|  '--'
										|  BOOLEAN_LITTERAL_TRUE
										|  BOOLEAN_LITTERAL_FALSE ;
		class_operator_decl_binary		-> type 'operator' overload_op_binary
											'(' type IDENTIFIER ',' type IDENTIFIER ')' ;
		overload_op_binary				-> '+'
										|  '-'
										|  '*'
										|  '/'
										|  '%'
										|  '&'
										|  '|'
										|  '^'
										|  '<<'
										|  '>|>'
										|  '=='
										|  '!='
										|  '>'
										|  '<'
										|  '>='
										|  '<=' ;
		class_operator_decl_conversion	-> 'implicit' 'operator' type '(' type IDENTIFIER ')'
										|  'explicit' 'operator' type '(' type IDENTIFIER ')' ;
		class_operator_body				-> stmt_block | ';' ;
		class_constructor				-> attributes class_access? 'extern'?
											class_constructor_decl class_constructor_body ;
		class_constructor_decl			-> IDENTIFIER '(' class_method_param_list? ')' class_constructor_init? ;
		class_constructor_init			-> ':' 'base' '(' exp_arg_list? ')'
										|  ':' 'this' '(' exp_arg_list? ')' ;
		class_constructor_body			-> stmt_block | ';' ;
		class_static_ctor				-> attributes class_static_ctor_modifiers
											IDENTIFIER '(' ')' class_static_ctor_body ;
		class_static_ctor_modifiers		-> 'extern' 'static'?
										|  'static' 'extern'? ;
		class_static_ctor_body			-> stmt_block | ';' ;
		class_destructor				-> attributes 'extern'? '~' IDENTIFIER '(' ')' class_destructor_body ;
		class_destructor_body			-> stmt_block | ';' ;
		
		
		/* B.2.8 Structs */
		struct_declaration				-> attributes class_access? 'new'? 'partial'?
											'struct' IDENTIFIER  type_parameter_list?
											struct_interfaces? type_param_cnstr_clauses?
											struct_body ';'? ;
		struct_interfaces				-> ':' name_nmspce_type (',' name_nmspce_type)* ;
		struct_body						-> '{' struct_member* '}' ;
		struct_member					-> class_constant
										|  class_field
										|  class_method
										|  class_property
										|  class_event
										|  class_indexer
										|  class_operator
										|  class_constructor
										|  class_static_ctor
										|  type_declaration ;
		
		
		/* B.2.10 Interfaces */
		inter_declaration				-> attributes class_access? 'new'? 'partial'?
											'interface' IDENTIFIER var_type_parameter_list?
											interface_base? type_param_cnstr_clauses?
											inter_body ';'? ;
		var_type_parameter_list			-> '<' var_type_params '>' ;
		var_type_params					-> var_type_param (',' var_type_param)* ;
		var_type_param					-> attributes var_annotation? type_parameter ;
		var_annotation					-> 'in' | 'out' ;
		interface_base					-> ':' name_nmspce_type (',' name_nmspce_type)* ;
		inter_body						-> '{' inter_member* '}' ;
		inter_member					-> inter_method
										|  inter_property
										|  inter_event
										|  inter_indexer ;
		inter_method					-> attributes 'new'? type_return
											IDENTIFIER type_parameter_list
											'(' class_method_param_list? ')'
											type_param_cnstr_clauses? ';' ;
		inter_property					-> attributes 'new'? type
											IDENTIFIER '{' inter_accessors '}' ;
		inter_accessors					-> attributes 'get' ';'
										|  attributes 'set' ';'
										|  attributes 'get' ';' attributes 'set' ';'
										|  attributes 'set' ';' attributes 'get' ';' ;
		inter_event						-> attributes 'new'? 'event' type IDENTIFIER ';' ;
		inter_indexer					-> attributes 'new'? type 'this'
											'[' class_method_param_list ']'
											'{' inter_accessors '}' ;
		
		
		/* B.2.11 */
		enum_declaration				-> attributes class_access? 'new'?
											'enum' IDENTIFIER
											enum_base? enum_body ';'? ;
		enum_base						-> ':' type_int ;
		enum_body						-> '{' enum_member* ','? '}' ;
		enum_member						-> attributes IDENTIFIER '=' expression ;
		
		
		/* B.2.12 */
		delg_declaration				-> attributes class_access? 'new'?
											'delegate' type_return
											IDENTIFIER var_type_parameter_list
											'(' class_method_param_list? ')'
											type_param_cnstr_clauses? ';' ;
		
		
		/* B.2.13 Attributes */
		attribute_argument_positional		-> (IDENTIFIER ':')? expression ;
		attribute_argument_named			-> IDENTIFIER '=' expression ;
		attribute_argument_positional_list	-> attribute_argument_positional (',' attribute_argument_positional)* ;
		attribute_argument_named_list		-> attribute_argument_named (',' attribute_argument_named)* ;
		attribute_argument_list				-> attribute_argument_positional_list?
											|  attribute_argument_positional_list ',' attribute_argument_named_list
											|  attribute_argument_named_list ;
		
		attribute_arguments					-> '(' attribute_argument_list ')' ;
		attribute							-> name_nmspce_type attribute_arguments? ;
		
		attribute_list						-> attribute (',' attribute)* ;
		attribute_target					-> 'field' | 'event' | 'method' | 'param' | 'property' | 'return' | 'type';
		attribute_section					-> '[' (attribute_target ':')? attribute_list ','? ']' ;
		attributes							-> attribute_section* ;
		
		global_attribute_target				-> 'assembly' | 'module' ;
		global_attribute_section			-> '[' global_attribute_target ':' attribute_list ','? ']' ;
		global_attributes					-> global_attribute_section* ;
	}
}