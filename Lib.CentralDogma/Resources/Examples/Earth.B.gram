namespace Hime.Earth.B
{
	public cf text grammar GrammarB
	{
		options
		{
			Axiom = "file";
			Separator = "SEPARATOR";
		}
		terminals
		{
			SPACE -> 0x0020;
			TAB -> 0x0009 | 0x000B;
			CR -> 0x000D;
			LF -> 0x000A;
			COMMENT -> '/*' ([^*] | '*' [^/])* '*/';
			BLANK -> SPACE | TAB | CR | LF | COMMENT;
			
			SEPARATOR		-> BLANK+;
			
			NAME				->	[a-zA-Z_] [0-9a-zA-Z_]* ;
			LITTERAL_INTEGER	-> [1-9][0-9]* | '0';
			LITTERAL_STRING		-> '"' [^"]* '"' ;
		}
		rules
		{
			/* Expression grammar */
				exp_names				-> NAME
										| '('! NAME (','! NAME)* ')'! ;
				exp_atom_id				-> NAME^ ('$' LITTERAL_INTEGER)? ;
				exp_atom_call			-> 'bool'^ '('! expression ')'!
										|  'succ'^ '('! expression ')'!
										|  'pred'^ '('! expression ')'!
										|  'max'^ '('! expression ')'!
										|  'min'^ '('! expression ')'!
										|  'card'^ '('! expression ')'!
										|  'SIGMA'^ exp_names '.'! '('! predicate '|'! expression ')'!
										|  'PI^' exp_names '.'! '('! predicate '|'! expression ')'!
										|  'POW'^ '('! expression ')'!
										|  'POW1'^ '('! expression ')'!
										|  'FIN'^ '('! expression ')'!
										|  'FIN1'^ '('! expression ')'!
										|  'union'^ '('! expression ')'!
										|  'inter'^ '('! expression ')'!
										|  'UNION'^ exp_names '.'! '('! predicate '|'! expression ')'!
										|  'INTER'^ exp_names '.'! '('! predicate '|'! expression ')'!
										|  'id'^ '('! expression ')'!
										|  'prj1'^ '('! expression ')'!
										|  'prj2'^ '('! expression ')'!
										|  'dom'^ '('! expression ')'!
										|  'ran'^ '('! expression ')'!
										|  '%'^ exp_names '.'! '('! predicate '|'! expression ')'!
										|  'fnc'^ '('! expression ')'!
										|  'rel'^ '('! expression ')'!
										|  'closure'^ '('! expression ')'!
										|  'closure1'^ '('! expression ')'!
										|  'seq'^ '('! expression ')'!
										|  'seq1'^ '('! expression ')'!
										|  'iseq'^ '('! expression ')'!
										|  'iseq1'^ '('! expression ')'!
										|  'perm'^ '('! expression ')'!
										|  'size'^ '('! expression ')'!
										|  'first'^ '('! expression ')'!
										|  'last'^ '('! expression ')'!
										|  'front'^ '('! expression ')'!
										|  'tail'^ '('! expression ')'!
										|  'rev'^ '('! expression ')'!
										|  'conc'^ '('! expression ')'!
										|  'tree'^ '('! expression ')'!
										|  'btree'^ '('! expression ')'!
										|  'const'^ '('! expression ')'!
										|  'top'^ '('! expression ')'!
										|  'sons'^ '('! expression ')'!
										|  'prefix'^ '('! expression ')'!
										|  'postfix'^ '('! expression ')'!
										|  'sizet'^ '('! expression ')'!
										|  'mirror'^ '('! expression ')'!
										|  'rank'^ '('! expression ')'!
										|  'father'^ '('! expression ')'!
										|  'son'^ '('! expression ')'!
										|  'subtree'^ '('! expression ')'!
										|  'arity'^ '('! expression ')'!
										|  'bin'^ '('! expression ')'!
										|  'left'^ '('! expression ')'!
										|  'right'^ '('! expression ')'!
										|  'infix'^ '('! expression ')'! ;
				
				exp_atom_litteral		-> LITTERAL_STRING^
										|  LITTERAL_INTEGER^
										|  'TRUE'^
										|  'FALSE'^
										|  'MAXINT'^
										|  'MININT'^ ;
				
				exp_atom_set_empty		-> '{'^ '}'! ;
				exp_atom_set_bool		-> 'BOOL'^ ;
				exp_atom_set_string		-> 'STRING'^ ;
				exp_atom_set_integer	-> 'INTEGER'^
										|  'NATURAL'^
										|  'NATURAL1'^
										|  'NAT'^
										|  'NAT1'^
										|  'INT'^ ;
				exp_atom_set_definition	-> '{'^ expression '|'! predicate '}'! ;
				exp_atom_set_enumerate	-> '{'^ expression '}'! ;
				
				exp_atom_serie			-> '['^ ']'!
										|  '['^ expression ']'! ;
				
				exp_atom				-> exp_atom_id^
										|  exp_atom_call^
										|  exp_atom_litteral^
										|  exp_atom_set_empty^
										|  exp_atom_set_bool^
										|  exp_atom_set_string^
										|  exp_atom_set_integer^
										|  exp_atom_set_definition^
										|  exp_atom_set_enumerate^
										|  exp_atom_serie^
										|  '('! expression^ ')'! ;
				
				exp_operator_250		-> exp_atom^
										|  exp_operator_250 '\''^ exp_atom ;
				exp_operator_230		-> exp_operator_250^
										|  exp_operator_230 '~'^ ;
				exp_operator_210		-> exp_operator_230^
										|  exp_operator_230 '('! expression? ')'! "func_call"^
										|  '-'^ exp_operator_230 ;
				exp_operator_200		-> exp_operator_210^
										|  exp_operator_210 '**'^ exp_operator_200 ;
				exp_operator_190		-> exp_operator_200^
										|  exp_operator_190 '*'^ exp_operator_200
										|  exp_operator_190 '/'^ exp_operator_200
										|  exp_operator_190 'mod'^ exp_operator_200 ;
				exp_operator_180		-> exp_operator_190^
										|  exp_operator_180 '+'^ exp_operator_190
										|  exp_operator_180 '-'^ exp_operator_190 ;
				exp_operator_170		-> exp_operator_180^
										|  exp_operator_170 '..'^ exp_operator_180 ;
				exp_operator_160		-> exp_operator_170^
										|  exp_operator_160 '\\/'^ exp_operator_170
										|  exp_operator_160 '/\\'^ exp_operator_170
										|  exp_operator_160 '->'^ exp_operator_170
										|  exp_operator_160 '\\|/'^ exp_operator_170
										|  exp_operator_160 '/|\\'^ exp_operator_170
										|  exp_operator_160 '<+'^ exp_operator_170
										|  exp_operator_160 '<|'^ exp_operator_170
										|  exp_operator_160 '|>'^ exp_operator_170
										|  exp_operator_160 '<<|'^ exp_operator_170
										|  exp_operator_160 '|>>'^ exp_operator_170
										|  exp_operator_160 '><'^ exp_operator_170
										|  exp_operator_160 '^'^ exp_operator_170
										|  exp_operator_160 '|->'^ exp_operator_170 ;
				exp_operator_125		-> exp_operator_160^
										|  exp_operator_125 '<->'^ exp_operator_160
										|  exp_operator_125 '+->'^ exp_operator_160
										|  exp_operator_125 '-->'^ exp_operator_160
										|  exp_operator_125 '+->>'^ exp_operator_160
										|  exp_operator_125 '-->>'^ exp_operator_160
										|  exp_operator_125 '>+>'^ exp_operator_160
										|  exp_operator_125 '>->'^ exp_operator_160
										|  exp_operator_125 '>->>'^ exp_operator_160 ;
				exp_operator_115		-> exp_operator_125^
										|  exp_operator_115 ','^ exp_operator_125 ;
				expression				-> exp_operator_115^ ;
			/* End of Expression grammar */
			
			
			
			
			/* Predicate grammar */					
				pred_atom				-> '!'^ exp_names '.'! '('! predicate ')'!	/* here the inner predicate must be a => */
										|  '#'^ exp_names '.'! '('! predicate ')'!
										|  'not'^ '('! predicate ')'!
										|  '('! predicate^ ')'!
										|  expression ':'^ expression
										|  expression '/:'^ expression
										|  expression '<:'^ expression
										|  expression '/<:'^ expression
										|  expression '<<:'^ expression
										|  expression '/<<:'^ expression
										|  expression '='^ expression
										|  expression '/='^ expression
										|  expression '<'^ expression
										|  expression '<='^ expression
										|  expression '>'^ expression
										|  expression '>='^ expression ;
				
				pred_operator_60		-> pred_atom^
										|  pred_operator_60 '<=>'^ pred_atom ;
				pred_operator_40		-> pred_operator_60^
										|  pred_operator_40 '&'^ pred_operator_60
										|  pred_operator_40 'or'^ pred_operator_60 ;
				pred_operator_30		-> pred_operator_40^
										|  pred_operator_30 '=>'^ pred_operator_40 ;
				
				predicate				-> pred_operator_30^ ;
			/* End of Predicate grammar */
			
			
			
			
			/* Substitution grammar */
				sub_atom_identifier		-> NAME^ ('$' LITTERAL_INTEGER)? ;
				sub_atom_identifiers	-> sub_atom_identifier (','! sub_atom_identifier)* ;
				sub_atom_identity		-> 'skip'^ ;
				sub_atom_block			-> 'BEGIN'! substitution^ 'END'! ;
				sub_atom_become_item	-> sub_atom_identifiers '::'^ expression ; 
				sub_atom_become_as		-> sub_atom_identifiers ':'^ '('! predicate ')'! ;
				sub_atom_become_equal	-> sub_atom_identifiers ':='^ expression
										|  sub_atom_identifier '('! expression ')'! ':='^ expression ;
				sub_atom_precondition	->  'PRE'^ predicate 'THEN'!
											substitution
											'END'! ;
				sub_atom_assertion		->	'ASSERT'^ predicate 'THEN'!
											substitution
											'END'! ;
				sub_atom_choice			->	'CHOICE'^ substitution
											('OR'! substitution)*
											'END'! ;
				sub_atom_if_elsif		->	'ELSIF'! predicate 'THEN'! substitution ;
				sub_atom_if_else		->	'ELSE'! substitution ;
				sub_atom_if				->	'IF'^ predicate 'THEN'! substitution
											sub_atom_if_elsif*
											sub_atom_if_else?
											'END'! ;
				sub_atom_select_when	->	'WHEN'! predicate 'THEN'! substitution ;
				sub_atom_select_else	->	'ELSE'! substitution ;
				sub_atom_select			->	'SELECT'^ predicate 'THEN'! substitution
											sub_atom_select_when*
											sub_atom_select_else?
											'END'! ;
				sub_atom_case_either	->	'EITHER'! expression 'THEN'! substitution ;
				sub_atom_case_or		->	'OR'! expression 'THEN'! substitution ;
				sub_atom_case_else		->	'ELSE'! substitution ;
				sub_atom_case			->	'CASE'^ expression 'OF'!
											sub_atom_case_either
											sub_atom_case_or*
											sub_atom_case_else?
											'END'! 'END'! ;
				sub_atom_any			->	'ANY'^ exp_names 'WHERE'! predicate 'THEN'! substitution 'END'! ;
				sub_atom_let_value		->  exp_names '='^ expression ;
				sub_atom_let			->	'LET'^ exp_names 'BE'!
											sub_atom_let_value ('&' sub_atom_let_value)*
											'IN'! substitution 'END'! ;
				sub_atom_var			->	'VAR'^ exp_names 'IN'! substitution 'END'! ;
				sub_atom_call			->	sub_atom_identifiers '<-'^ sub_atom_identifier ('('! expression ')'!)? ;
				sub_atom				-> sub_atom_identity^
										|  sub_atom_block^
										|  sub_atom_become_item^
										|  sub_atom_become_as^
										|  sub_atom_become_equal^
										|  sub_atom_precondition^
										|  sub_atom_assertion^
										|  sub_atom_choice^
										|  sub_atom_if^
										|  sub_atom_select^
										|  sub_atom_case^
										|  sub_atom_any^
										|  sub_atom_let^
										|  sub_atom_var^
										|  sub_atom_call^ ;
				
				sub_operator_20			-> sub_atom^
										|  sub_operator_20 ';'^ sub_atom
										|  sub_operator_20 '||'^ sub_atom ;
				
				substitution			-> sub_operator_20^ ;
				
				
				
				
				/*
				Substitution_corps_opération8UUV8
					88 Substitution_bloc8
					8|8 Substitution_identitE
					8|8 Substitution_devient_égal8
					8|8 Substitution_précondition8
					8|8 Substitution_assertion8
					8|8 Substitution_choix_bornE
					8|8 Substitution_conditionnelle8
					8|8 Substitution_sélection8
					8|8 Substitution_cas8
					8|8 Substitution_any8
					8|8 Substitution_let8
					8|8 Substitution_devient_elt_de8
					8|8 Substitution_devient_tel_que8
					8|8 Substitution_variable_locale8
					8|8 Substitution_appel_opération8
					
				Instruction_corps_opération8UUV8
					88 Instruction_bloc8
					8|8 Instruction_variable_locale8
					8|8 Substitution_identitE
					8|8 Instruction_devient_égal8
					8|8 Instruction_appel_opération8
					8|8 Instruction_conditionnelle8
					8|8 Instruction_cas8
					8|8 Instruction_assertion8
					8|8 Substitution_tant_que8
					
				Substitution8UUV8
					88 Substitution_bloc8
					8|8 Substitution_identitE
					8|8 Substitution_devient_égal8
					8|8 Substitution_précondition8
					8|8 Substitution_assertion8
					8|8 Substitution_choix_bornE
					8|8 Substitution_conditionnelle8
					8|8 Substitution_sélection8
					8|8 Substitution_cas8
					8|8 Substitution_choix_non_bornE
					8|8 Substitution_définition_locale8
					8|8 Substitution_devient_elt_de8
					8|8 Substitution_devient_tel_que8
					8|8 Substitution_variable_locale8
					8|8 Substitution_séquence88
					8|8 Substitution_appel_opération8
					8|8 Substitution_simultanéeT
					8|8 Substitution_tant_que8
				
				Substitution_corps_opération8UUV8
					88 Substitution_bloc8
					8|8 Substitution_identitE
					8|8 Substitution_devient_égal8
					8|8 Substitution_précondition8
					8|8 Substitution_assertion8
					8|8 Substitution_choix_bornE
					8|8 Substitution_conditionnelle8
					8|8 Substitution_sélection8
					8|8 Substitution_cas8
					8|8 Substitution_any8
					8|8 Substitution_let8
					8|8 Substitution_devient_elt_de8
					8|8 Substitution_devient_tel_que8
					8|8 Substitution_variable_locale8
					8|8 Substitution_appel_opération8
				*/
			/* End of substitution grammar */
			
			
			
			
			/* Clauses grammar */
				clause_names			-> NAME (','! NAME)* ;
				clause_constraints		-> 'CONSTRAINTS'^ predicate ;
				clause_refines			-> 'REFINES'^ NAME ;
				clause_sees				-> 'SEES'^ clause_names ;
				clause_promotes			-> 'PROMOTES'^ clause_names ;
				clause_uses				-> 'USES'^ clause_names ;
				clause_set				-> NAME^
										|  NAME^ '='! '{'! clause_names '}'! ;
				clause_sets				-> 'SETS'^ clause_set (';'! clause_set)* ;
				clause_const_concrete	-> ('CONCRETE_CONSTANTS' | 'CONSTANTS')^ clause_names ;
				clause_const_abstract	-> 'ABSTRACT_CONSTANTS'^ clause_names ;
				clause_properties		-> 'PROPERTIES'^ predicate ;
				clause_var_concrete		-> 'CONCRETE_VARIABLES'^ clause_names ;
				clause_var_abstract		-> ('ABSTRACT_VARIABLES' | 'VARIABLES')^ clause_names ;
				clause_invariant		-> 'INVARIANT'^ predicate ;
				clause_assertion		-> 'ASSERTIONS'^ predicate (';'! predicate)* ;
				clause_initialisation	-> 'INITIALISATION'^ substitution ;
				clause_operation_head	-> (clause_names '<--'!)? NAME ('('! clause_names ')'!)? ;
				clause_operation		-> clause_operation_head '='! substitution ;
				clause_operations		-> 'OPERATIONS'^ clause_operation+ ;

				clause_machine			-> clause_constraints^
										|  clause_sees^
										|  clause_promotes^
										|  clause_uses^
										|  clause_sets^
										|  clause_const_concrete^
										|  clause_const_abstract^
										|  clause_properties^
										|  clause_var_concrete^
										|  clause_var_abstract^
										|  clause_invariant^
										|  clause_assertion^
										|  clause_initialisation^
										|  clause_operations^ ;
			/* End of clauses grammar */
			
			
			
			
			
			/* Component grammar */
				component_head			-> NAME^ ('('! NAME (','! NAME)* ')'!)? ;
				component_machine		-> 'MACHINE'^ component_head clause_machine* 'END'!;
				
				component				-> component_machine^ ;
			/* End of component grammar */
			
			
			file	-> component*;
		}
	}
}