/*******************************************************************************
 * Copyright (c) 2017 Association Cénotélie (cenotelie.fr)
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

using System.Collections.Generic;
using System.IO;
using System.Text;
using Hime.Redist.Utils;
using Hime.SDK.Grammars;

namespace Hime.SDK.Output
{
	/// <summary>
	/// Represents a generator for parser code for the .Net platform
	/// </summary>
	public class ParserNetCodeGenerator : Generator
	{
		/// <summary>
		/// The nmespace of the generated code
		/// </summary>
		private readonly string nmespace;
		/// <summary>
		/// The visibility modifier for the generated code
		/// </summary>
		private readonly Modifier modifier;
		/// <summary>
		/// The name of the generated lexer
		/// </summary>
		private readonly string name;
		/// <summary>
		/// Path to the automaton's binary resource
		/// </summary>
		private readonly string binResource;
		/// <summary>
		/// The grammar to generate a parser for
		/// </summary>
		private readonly Grammar grammar;
		/// <summary>
		/// The type of the parser to generate
		/// </summary>
		private readonly string parserType;
		/// <summary>
		/// The type of the automaton
		/// </summary>
		private readonly string automatonType;
		/// <summary>
		/// The terminals for the lexer
		/// </summary>
		private readonly ROList<Terminal> terminals;
		/// <summary>
		/// The variables to be exported
		/// </summary>
		private readonly List<Variable> variables;
		/// <summary>
		/// The virtual symbols to be exported
		/// </summary>
		private readonly List<Virtual> virtuals;
		/// <summary>
		/// The action symbols to be exported
		/// </summary>
		private readonly List<Action> actions;

		/// <summary>
		/// Initializes this code generator
		/// </summary>
		/// <param name="unit">The unit to generate code for</param>
		/// <param name="binResource">Path to the automaton's binary resource</param>
		public ParserNetCodeGenerator(Unit unit, string binResource)
		{
			this.nmespace = Helper.GetNamespaceForCS(unit.Namespace == null ? unit.Grammar.Name : unit.Namespace);
			this.modifier = unit.Modifier;
			this.name = unit.Name;
			this.binResource = binResource;
			this.grammar = unit.Grammar;
			if (unit.Method == ParsingMethod.RNGLR1 || unit.Method == ParsingMethod.RNGLALR1)
			{
				this.parserType = "RNGLRParser";
				this.automatonType = "RNGLRAutomaton";
			}
			else
			{
				this.parserType = "LRkParser";
				this.automatonType = "LRkAutomaton";
			}
			terminals = unit.Expected;
			variables = new List<Variable>(unit.Grammar.Variables);
			virtuals = new List<Virtual>(unit.Grammar.Virtuals);
			actions = new List<Action>(unit.Grammar.Actions);
			variables.Sort(new Grammars.Symbol.IdComparer<Variable>());
			virtuals.Sort(new Grammars.Symbol.IdComparer<Virtual>());
			actions.Sort(new Grammars.Symbol.IdComparer<Action>());
		}

		/// <summary>
		/// Writes a generated .Net file header
		/// </summary>
		/// <param name="writer">The writer to write to</param>
		private void WriteHeader(StreamWriter writer)
		{
			writer.WriteLine("/*");
			writer.WriteLine(" * WARNING: this file has been generated by");
			writer.WriteLine(" * Hime Parser Generator " + CompilationTask.Version);
			writer.WriteLine(" */");
		}

		/// <summary>
		/// Generates code for the specified file
		/// </summary>
		/// <param name="file">The target file to generate code in</param>
		public void Generate(string file)
		{
			StreamWriter writer = new StreamWriter(file, false, new UTF8Encoding(false));

			WriteHeader(writer);

			writer.WriteLine("using System.Collections.Generic;");
			writer.WriteLine("using Hime.Redist;");
			writer.WriteLine("using Hime.Redist.Parsers;");
			writer.WriteLine();
			writer.WriteLine("namespace " + nmespace);
			writer.WriteLine("{");
			writer.WriteLine("\t/// <summary>");
			writer.WriteLine("\t/// Represents a parser");
			writer.WriteLine("\t/// </summary>");
			writer.WriteLine("\t" + modifier.ToString().ToLower() + " class " + name + "Parser : " + parserType);
			writer.WriteLine("\t{");

			writer.WriteLine("\t\t/// <summary>");
			writer.WriteLine("\t\t/// The automaton for this parser");
			writer.WriteLine("\t\t/// </summary>");
			writer.WriteLine("\t\tprivate static readonly " + automatonType + " commonAutomaton = " + automatonType + ".Find(typeof(" + name + "Parser), \"" + binResource + "\");");

			GenerateCodeSymbols(writer);
			GenerateCodeVariables(writer);
			GenerateCodeVirtuals(writer);
			GenerateCodeActions(writer);
			GenerateCodeConstructors(writer);
			GenerateCodeVisitor(writer);

			writer.WriteLine("\t}");
			writer.WriteLine("}");
			writer.Close();
		}

		/// <summary>
		/// Generates the code for the symbols
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeSymbols(StreamWriter stream)
		{
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Contains the constant IDs for the variables and virtuals in this parser");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tpublic class ID");
			stream.WriteLine("\t\t{");
			foreach (Variable var in variables)
			{
				if (var.Name.StartsWith(Grammar.PREFIX_GENERATED_VARIABLE))
					continue;
				stream.WriteLine("\t\t\t/// <summary>");
				stream.WriteLine("\t\t\t/// The unique identifier for variable " + var.Name);
				stream.WriteLine("\t\t\t/// </summary>");
				stream.WriteLine("\t\t\tpublic const int Variable{0} = 0x{1};", Helper.ToUpperCamelCase(var.Name), var.ID.ToString("X4"));
			}
			foreach (Virtual var in virtuals)
			{
				stream.WriteLine("\t\t\t/// <summary>");
				stream.WriteLine("\t\t\t/// The unique identifier for virtual " + var.Name);
				stream.WriteLine("\t\t\t/// </summary>");
				stream.WriteLine("\t\t\tpublic const int Virtual{0} = 0x{1};", Helper.ToUpperCamelCase(var.Name), var.ID.ToString("X4"));
			}
			stream.WriteLine("\t\t}");
		}

		/// <summary>
		/// Generates the code for the variables
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeVariables(StreamWriter stream)
		{
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// The collection of variables matched by this parser");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\t/// <remarks>");
			stream.WriteLine("\t\t/// The variables are in an order consistent with the automaton,");
			stream.WriteLine("\t\t/// so that variable indices in the automaton can be used to retrieve the variables in this table");
			stream.WriteLine("\t\t/// </remarks>");
			stream.WriteLine("\t\tprivate static readonly Symbol[] variables = {");
			bool first = true;
			foreach (Variable var in variables)
			{
				if (!first)
					stream.WriteLine(", ");
				stream.Write("\t\t\t");
				stream.Write("new Symbol(0x" + var.ID.ToString("X4") + ", \"" + var.Name + "\")");
				first = false;
			}
			stream.WriteLine(" };");
		}

		/// <summary>
		/// Generates the code for the virtual symbols
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeVirtuals(StreamWriter stream)
		{
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// The collection of virtuals matched by this parser");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\t/// <remarks>");
			stream.WriteLine("\t\t/// The virtuals are in an order consistent with the automaton,");
			stream.WriteLine("\t\t/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table");
			stream.WriteLine("\t\t/// </remarks>");
			stream.WriteLine("\t\tprivate static readonly Symbol[] virtuals = {");
			bool first = true;
			foreach (Virtual v in virtuals)
			{
				if (!first)
					stream.WriteLine(", ");
				stream.Write("\t\t\t");
				stream.Write("new Symbol(0x" + v.ID.ToString("X4") + ", \"" + v.Name + "\")");
				first = false;
			}
			stream.WriteLine(" };");
		}

		/// <summary>
		/// Generates the code for the semantic actions
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeActions(StreamWriter stream)
		{
			if (actions.Count == 0)
				return;
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Represents a set of semantic actions in this parser");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tpublic class Actions");
			stream.WriteLine("\t\t{");
			foreach (Action action in actions)
			{
				stream.WriteLine("\t\t\t/// <summary>");
				stream.WriteLine("\t\t\t/// The " + action.Name + " semantic action");
				stream.WriteLine("\t\t\t/// </summary>");
				stream.WriteLine("\t\t\tpublic virtual void " + Helper.ToUpperCamelCase(action.Name) + "(Symbol head, SemanticBody body) {}");
			}
			stream.WriteLine();
			stream.WriteLine("\t\t}");

			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Represents a set of empty semantic actions (do nothing)");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tprivate static readonly Actions noActions = new Actions();");

			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Gets the set of semantic actions in the form a table consistent with the automaton");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\t/// <param name=\"input\">A set of semantic actions</param>");
			stream.WriteLine("\t\t/// <returns>A table of semantic actions</returns>");
			stream.WriteLine("\t\tprivate static SemanticAction[] GetUserActions(Actions input)");
			stream.WriteLine("\t\t{");
			stream.WriteLine("\t\t\tSemanticAction[] result = new SemanticAction[" + actions.Count + "];");
			int i = 0;
			foreach (Action action in actions)
			{
				stream.WriteLine("\t\t\tresult[" + i + "] = new SemanticAction(input." + Helper.ToUpperCamelCase(action.Name) + ");");
				i++;
			}
			stream.WriteLine("\t\t\treturn result;");
			stream.WriteLine("\t\t}");

			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Gets the set of semantic actions in the form a table consistent with the automaton");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\t/// <param name=\"input\">A set of semantic actions</param>");
			stream.WriteLine("\t\t/// <returns>A table of semantic actions</returns>");
			stream.WriteLine("\t\tprivate static SemanticAction[] GetUserActions(Dictionary<string, SemanticAction> input)");
			stream.WriteLine("\t\t{");
			stream.WriteLine("\t\t\tSemanticAction[] result = new SemanticAction[" + actions.Count + "];");
			i = 0;
			foreach (Action action in actions)
			{
				stream.WriteLine("\t\t\tresult[" + i + "] = input[\"" + action.Name + "\"];");
				i++;
			}
			stream.WriteLine("\t\t\treturn result;");
			stream.WriteLine("\t\t}");
		}

		/// <summary>
		/// Generates the code for the constructors
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeConstructors(StreamWriter stream)
		{
			if (actions.Count == 0)
			{
				stream.WriteLine("\t\t/// <summary>");
				stream.WriteLine("\t\t/// Initializes a new instance of the parser");
				stream.WriteLine("\t\t/// </summary>");
				stream.WriteLine("\t\t/// <param name=\"lexer\">The input lexer</param>");
				stream.WriteLine("\t\tpublic " + name + "Parser(" + name + "Lexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }");
			}
			else
			{
				stream.WriteLine("\t\t/// <summary>");
				stream.WriteLine("\t\t/// Initializes a new instance of the parser");
				stream.WriteLine("\t\t/// </summary>");
				stream.WriteLine("\t\t/// <param name=\"lexer\">The input lexer</param>");
				stream.WriteLine("\t\tpublic " + name + "Parser(" + name + "Lexer lexer) : base (commonAutomaton, variables, virtuals, GetUserActions(noActions), lexer) { }");

				stream.WriteLine("\t\t/// <summary>");
				stream.WriteLine("\t\t/// Initializes a new instance of the parser");
				stream.WriteLine("\t\t/// </summary>");
				stream.WriteLine("\t\t/// <param name=\"lexer\">The input lexer</param>");
				stream.WriteLine("\t\t/// <param name=\"actions\">The set of semantic actions</param>");
				stream.WriteLine("\t\tpublic " + name + "Parser(" + name + "Lexer lexer, Actions actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }");

				stream.WriteLine("\t\t/// <summary>");
				stream.WriteLine("\t\t/// Initializes a new instance of the parser");
				stream.WriteLine("\t\t/// </summary>");
				stream.WriteLine("\t\t/// <param name=\"lexer\">The input lexer</param>");
				stream.WriteLine("\t\t/// <param name=\"actions\">The set of semantic actions</param>");
				stream.WriteLine("\t\tpublic " + name + "Parser(" + name + "Lexer lexer, Dictionary<string, SemanticAction> actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }");
			}
		}

		/// <summary>
		/// Generates the visitor for the parse result
		/// </summary>
		/// <param name="stream">The output stream</param>
		private void GenerateCodeVisitor(StreamWriter stream)
		{
			stream.WriteLine("");
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Visitor interface");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tpublic class Visitor");
			stream.WriteLine("\t\t{");
			foreach (Terminal terminal in terminals)
			{
				if (terminal.ID <= 2 || terminal.Name.StartsWith(Grammar.PREFIX_GENERATED_TERMINAL))
					continue;
				stream.WriteLine("\t\t\tpublic virtual void OnTerminal" + Helper.ToUpperCamelCase(terminal.Name) + "(ASTNode node) {}");
			}
			foreach (Variable var in variables)
			{
				if (var.Name.StartsWith(Grammar.PREFIX_GENERATED_VARIABLE))
					continue;
				stream.WriteLine("\t\t\tpublic virtual void OnVariable" + Helper.ToUpperCamelCase(var.Name) + "(ASTNode node) {}");
			}
			foreach (Virtual var in virtuals)
			{
				stream.WriteLine("\t\t\tpublic virtual void OnVirtual" + Helper.ToUpperCamelCase(var.Name) + "(ASTNode node) {}");
			}
			stream.WriteLine("\t\t}");
			stream.WriteLine("");
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Walk the AST using a visitor");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tpublic static void Visit(ParseResult result, Visitor visitor)");
			stream.WriteLine("\t\t{");
			stream.WriteLine("\t\t\tVisitASTNode(result.Root, visitor);");
			stream.WriteLine("\t\t}");
			stream.WriteLine("");
			stream.WriteLine("\t\t/// <summary>");
			stream.WriteLine("\t\t/// Walk the AST using a visitor");
			stream.WriteLine("\t\t/// </summary>");
			stream.WriteLine("\t\tpublic static void VisitASTNode(ASTNode node, Visitor visitor)");
			stream.WriteLine("\t\t{");
			stream.WriteLine("\t\t\tfor (int i = 0; i < node.Children.Count; i++)");
			stream.WriteLine("\t\t\t\tVisitASTNode(node.Children[i], visitor);");
			stream.WriteLine("\t\t\tswitch(node.Symbol.ID)");
			stream.WriteLine("\t\t\t{");
			foreach (Terminal terminal in terminals)
			{
				if (terminal.ID <= 2 || terminal.Name.StartsWith(Grammar.PREFIX_GENERATED_TERMINAL))
					continue;
				stream.WriteLine("\t\t\t\tcase 0x" + terminal.ID.ToString("X4") + ": visitor.OnTerminal" + Helper.ToUpperCamelCase(terminal.Name) + "(node); break;");
			}
			foreach (Variable var in variables)
			{
				if (var.Name.StartsWith(Grammar.PREFIX_GENERATED_VARIABLE))
					continue;
				stream.WriteLine("\t\t\t\tcase 0x" + var.ID.ToString("X4") + ": visitor.OnVariable" + Helper.ToUpperCamelCase(var.Name) + "(node); break;");
			}
			foreach (Virtual var in virtuals)
			{
				stream.WriteLine("\t\t\t\tcase 0x" + var.ID.ToString("X4") + ": visitor.OnVirtual" + Helper.ToUpperCamelCase(var.Name) + "(node); break;");
			}
			stream.WriteLine("\t\t\t}");
			stream.WriteLine("\t\t}");
		}
	}
}
